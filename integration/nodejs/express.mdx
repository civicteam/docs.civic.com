---
title: "Express"
description: "Follow these simple steps to set up Civic Auth with an [Express](https://expressjs.com/) backend (a working example is available in our [github examples repo](https://github.com/civicteam/civic-auth-examples/tree/main/packages/civic-auth/server/express))."
icon: js
public: true
---

## 1. Install dependencies

<CodeGroup>
  ```npm npm
  npm install @civic/auth cookie-parser
  ```

```yarn yarn
yarn add @civic/auth cookie-parser
```

```pnpm pnpm
pnpm install @civic/auth cookie-parser
```

```bun bun
bun add @civic/auth cookie-parser
```

</CodeGroup>

## 2. Setup with CivicAuthServer (Recommended)

ðŸš€ **NEW SIMPLIFIED APPROACH**: The easiest way to set up Civic Auth with Express is using the `CivicAuthServer` middleware that automatically handles all auth routes, storage, and CORS configuration.

This approach eliminates the need for manual endpoint creation, cookie storage setup, and CORS configuration. The middleware automatically creates all necessary auth routes and handles session management, making it perfect for both traditional server-rendered apps and modern SPA architectures.

```ts
import express from "express";
import cookieParser from "cookie-parser";
import { CivicAuthServer } from "@civic/auth/server";

const app = express();

// REQUIRED: Cookie parser middleware for session management
app.use(cookieParser());

// ðŸš€ ONE LINE SETUP: Everything is handled automatically!
app.use(
  CivicAuthServer({
    clientId: process.env.CLIENT_ID!,
    redirectUrl: `http://localhost:3020/auth/callback`,
    postLogoutRedirectUrl: `http://localhost:3020/`,

    // Optional: Redirect SPAs back to frontend after auth
    frontendRedirectUrl: "http://localhost:5173",

    // Optional: OAuth server (defaults to production)
    oauthServer: process.env.OAUTH_SERVER ?? "https://auth.civic.com/oauth",

    // Optional: CORS is auto-configured from your URLs, but you can customize
    // cors: {
    //   origin: ["https://additional-domain.com"],
    //   credentials: true,
    // },

    // Optional: Logging configuration
    logger: {
      enabled: true, // Set to false to disable all logging
    },
  }),
);
```

## 3. Add Authentication Middleware

Protect routes that require login:

```ts
import { Request, Response, NextFunction } from "express";
import type { CivicAuth, SessionStorage } from "@civic/auth/server";

// Type for requests with auth properties (auto-added by CivicAuthServer)
type RequestWithAuth = Request & {
  storage?: SessionStorage;
  civicAuth?: CivicAuth;
};

const authMiddleware = async (req: RequestWithAuth, res: Response, next: NextFunction) => {
  if (!(await req.civicAuth!.isLoggedIn())) {
    return res.status(401).send("Unauthorized");
  }
  next();
};

// Apply authentication middleware to protected routes
app.use("/admin", authMiddleware);
```

## 4. Use Protected Routes

Access user information in your protected routes:

```ts
app.get("/admin/hello", async (req: RequestWithAuth, res: Response) => {
  const user = await req.civicAuth!.getUser();
  res.send(`Hello, ${user?.name || user?.email || "User"}!`);
});

// Optional: Manual token refresh
app.get("/admin/refresh", async (req: RequestWithAuth, res: Response) => {
  await req.civicAuth!.refreshTokens();
  res.send("Tokens refreshed");
});
```

## 5. Automatic Routes

When using `CivicAuthServer`, these routes are automatically created for you:

- `GET /auth/login` - Redirects to Civic Auth login
- `GET /auth/callback` - Handles OAuth callback
- `GET /auth/logout` - Handles logout and redirects to `postLogoutRedirectUrl`
- `GET /auth/user` - Returns current user info (if logged in)
- `POST /auth/refresh` - Refreshes tokens

You can trigger login from any route:

```ts
app.get("/", async (req: RequestWithAuth, res: Response) => {
  const url = await req.civicAuth!.buildLoginUrl();
  res.redirect(url.toString());
});
```

## 6. Frontend Integration (Vanilla JavaScript)

Your Express backend works seamlessly with vanilla JavaScript frontends. Instead of using the `@civic/auth/vanillajs` client-side approach, you can make HTTP calls to your backend's automatic auth routes:

### HTML Setup

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My App with Civic Auth</title>
  </head>
  <body>
    <div id="app">
      <button id="loginButton">Sign In</button>
      <button id="logoutButton">Sign Out</button>
      <div id="userInfo"></div>
    </div>
    <script src="main.js"></script>
  </body>
</html>
```

### JavaScript Frontend

```javascript
// main.js
const API_BASE = "http://localhost:3020"; // Your Express server URL

// Check if user is logged in on page load
window.addEventListener("DOMContentLoaded", async () => {
  await checkAuthStatus();
  setupEventListeners();
});

async function checkAuthStatus() {
  try {
    const response = await fetch(`${API_BASE}/auth/user`, {
      credentials: "include", // Important: Include cookies
    });

    if (response.ok) {
      const user = await response.json();
      showUserInfo(user);
    } else {
      showLoginButton();
    }
  } catch (error) {
    console.error("Auth check failed:", error);
    showLoginButton();
  }
}

function setupEventListeners() {
  document.getElementById("loginButton").addEventListener("click", login);
  document.getElementById("logoutButton").addEventListener("click", logout);
}

async function login() {
  // Redirect to your backend's login endpoint
  window.location.href = `${API_BASE}/auth/login`;
}

async function logout() {
  // Redirect to your backend's logout endpoint
  window.location.href = `${API_BASE}/auth/logout`;
}

function showUserInfo(user) {
  document.getElementById("loginButton").style.display = "none";
  document.getElementById("logoutButton").style.display = "block";
  document.getElementById("userInfo").innerHTML = `
        <h3>Welcome, ${user.name || user.email}!</h3>
        <p>You are logged in</p>
    `;
}

function showLoginButton() {
  document.getElementById("loginButton").style.display = "block";
  document.getElementById("logoutButton").style.display = "none";
  document.getElementById("userInfo").innerHTML = "";
}
```

### Advanced: SPA Integration

For single-page applications, you can use the `frontendRedirectUrl` option to automatically redirect back to your frontend after authentication:

```ts
// In your Express setup
app.use(
  CivicAuthServer({
    clientId: process.env.CLIENT_ID!,
    redirectUrl: `http://localhost:3020/auth/callback`,
    postLogoutRedirectUrl: `http://localhost:3020/`,
    frontendRedirectUrl: "http://localhost:5173", // Your frontend URL
  }),
);
```

Then in your frontend, handle the redirect:

```javascript
// Check for auth completion (when redirected back from backend)
const urlParams = new URLSearchParams(window.location.search);
if (urlParams.get("auth") === "success") {
  // Authentication successful, check user status
  await checkAuthStatus();
  // Clean up URL
  window.history.replaceState({}, document.title, window.location.pathname);
}
```

## Manual Setup (Advanced)

<details>
<summary>If you need custom storage or more control, you can still set up Civic Auth manually:</summary>

### Configure your App

```ts
const config = {
  clientId: process.env.CLIENT_ID!,
  redirectUrl: "http://localhost:3000/auth/callback",
  postLogoutRedirectUrl: "http://localhost:3000/",
};
```

### Set up Custom Storage

```ts
import { CookieStorage, CivicAuth } from "@civic/auth/server";

class ExpressCookieStorage extends CookieStorage {
  constructor(
    private req: Request,
    private res: Response,
  ) {
    super({
      secure: false,
    });
  }

  async get(key: string): Promise<string | null> {
    return Promise.resolve(this.req.cookies[key] ?? null);
  }

  async set(key: string, value: string): Promise<void> {
    await this.res.cookie(key, value, this.settings);
  }
}

app.use((req, res, next) => {
  req.storage = new ExpressCookieStorage(req, res);
  req.civicAuth = new CivicAuth(req.storage, config);
  next();
});
```

### Create Manual Endpoints

```ts
// Login endpoint
app.get("/auth/login", async (req: Request, res: Response) => {
  const url = await req.civicAuth.buildLoginUrl();
  res.redirect(url.toString());
});

// Logout endpoint
app.get("/auth/logout", async (req: Request, res: Response) => {
  const url = await req.civicAuth.buildLogoutRedirectUrl();
  res.redirect(url.toString());
});

// Callback endpoint
app.get("/auth/callback", async (req: Request, res: Response) => {
  const { code, state } = req.query as { code: string; state: string };
  await req.civicAuth.resolveOAuthAccessCode(code, state);
  res.redirect("/admin/hello");
});
```

</details>

## PKCE and Client Secrets

Civic Auth uses [**PKCE** (Proof Key for Code Exchange)](https://oauth.net/2/pkce/), to protect users and clients from unauthorized access to user information. This, alongside domain registration for apps in production environments, mean that you don't need to provide a client secret in your backend.

When using the Civic Auth SDK, PKCE is handled entirely by the library.
